<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- SEO & Metadata -->
    <title>Data Structures & Algorithms - Whizmath | Master Fundamentals for Beginners</title>
    <meta name="description" content="Master fundamental Data Structures & Algorithms for beginners and intermediate learners at Whizmath. Explore essential concepts like Arrays, Linked Lists, Trees, Graphs, Sorting, Searching, Recursion, Dynamic Programming, and Big O Notation for efficient coding.">
    <meta name="keywords" content="Data Structures, Algorithms, Big O Notation, Arrays, Linked Lists, Stacks, Queues, Trees, Graphs, Hash Tables, Searching Algorithms, Sorting Algorithms, Linear Search, Binary Search, Bubble Sort, Merge Sort, Quick Sort, BFS, DFS, Recursion, Dynamic Programming, Greedy Algorithms, Computer Science, Programming, Learn DSA, Algorithm Efficiency, Whizmath">
    <link rel="canonical" href="https://whizmath.com/dsa.html"> <!-- Replace with your actual URL -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8470165109508371"
     crossorigin="anonymous"></script>
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://whizmath.com/dsa.html"> <!-- Replace with your actual URL -->
    <meta property="og:title" content="Data Structures & Algorithms - Whizmath | Master Fundamentals for Beginners">
    <meta property="og:description" content="Master fundamental Data Structures & Algorithms for beginners and intermediate learners at Whizmath. Explore essential concepts like Arrays, Linked Lists, Trees, Graphs, Sorting, Searching, Recursion, Dynamic Programming, and Big O Notation for efficient coding.">
    <meta property="og:image" content="https://placehold.co/1200x630/63b3ed/ffffff?text=Whizmath+DSA"> <!-- Placeholder image for social share -->
    <meta property="og:site_name" content="Whizmath">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://whizmath.com/dsa.html"> <!-- Replace with your actual URL -->
    <meta property="twitter:title" content="Data Structures & Algorithms - Whizmath | Master Fundamentals for Beginners">
    <meta property="twitter:description" content="Master fundamental Data Structures & Algorithms for beginners and intermediate learners at Whizmath. Explore essential concepts like Arrays, Linked Lists, Trees, Graphs, Sorting, Searching, Recursion, Dynamic Programming, and Big O Notation for efficient coding.">
    <meta property="twitter:image" content="https://placehold.co/1200x630/63b3ed/ffffff?text=Whizmath+DSA"> <!-- Placeholder image for social share -->

    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://yourdomain.com/ds_algo_lesson.html"
      },
      "headline": "Data Structures & Algorithms - Master Fundamental Concepts for Beginners & Intermediate Learners",
      "description": "A comprehensive lesson on core data structures (Arrays, Linked Lists, Trees, Graphs, Hash Tables) and essential algorithms (Searching, Sorting, Traversal, Recursion, Dynamic Programming) with Big O analysis. Perfect for those looking to build efficient software and excel in technical problem-solving.",
      "image": "https://placehold.co/1200x630/63b3ed/ffffff?text=Whizmath+DSA",
      "author": {
        "@type": "Organization",
        "name": "Whizmath"
      },
      "publisher": {
        "@type": "Organization",
        "name": "Whizmath",
        "logo": {
          "@type": "ImageObject",
          "url": "https://placehold.co/600x60/63b3ed/ffffff?text=Whizmath+Logo" <!-- Placeholder logo for publisher -->
        }
      },
      "datePublished": "2025-06-07T09:00:00+01:00", <!-- Update with actual publish date/time -->
      "dateModified": "2025-06-07T09:00:00+01:00",  <!-- Update with actual modify date/time -->
      "keywords": "Data Structures, Algorithms, Big O Notation, Arrays, Linked Lists, Stacks, Queues, Trees, Graphs, Hash Tables, Searching Algorithms, Sorting Algorithms, Linear Search, Binary Search, Bubble Sort, Merge Sort, Quick Sort, BFS, DFS, Recursion, Dynamic Programming, Greedy Algorithms, Computer Science, Programming, Learn DSA, Algorithm Efficiency, Whizmath"
    }
    </script>

    <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background for professional look */
            color: #e6e6e6; /* Light text for contrast */
            overflow-x: hidden; /* Prevent horizontal scroll */
            position: relative; /* For scroll-to-top positioning */
        }
        #three-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; /* Send it to the back */
            overflow: hidden;
        }
        .content-wrapper {
            position: relative;
            z-index: 1; /* Keep content above background */
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem 1rem;
            background-color: rgba(17, 24, 39, 0.9); /* Slightly transparent dark background for content */
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px); /* Subtle blur effect */
            -webkit-backdrop-filter: blur(8px);
        }
        h1, h2, h3, h4 {
            color: #63b3ed; /* A vibrant blue for headings */
            font-weight: 700;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        h1 { font-size: 2.5rem; }
        h2 { font-size: 2rem; }
        h3 { font-size: 1.75rem; }
        h4 { font-size: 1.5rem; }
        p {
            line-height: 1.8;
            margin-bottom: 1rem;
        }
        a {
            color: #a78bfa; /* A subtle purple for links */
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .code-block {
            position: relative;
            background-color: #1f2937; /* Darker background for code */
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
            overflow-x: auto; /* Enable horizontal scrolling for long lines of code */
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .code-block pre {
            margin: 0;
            padding: 0;
        }
        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #4a5568; /* Grayish background for button */
            color: #e6e6e6;
            padding: 0.4rem 0.8rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out;
            border: none;
            outline: none;
        }
        .copy-button:hover {
            background-color: #646b7a;
        }
        .back-button {
            position: fixed;
            top: 2rem;
            left: 2rem;
            z-index: 100;
            background-color: #63b3ed;
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 9999px; /* Fully rounded */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background-color 0.3s ease, transform 0.2s ease;
            text-decoration: none;
            font-weight: 600;
        }
        .back-button:hover {
            background-color: #4299e1;
            transform: translateY(-2px);
        }
        .back-button svg {
            width: 1.25rem;
            height: 1.25rem;
        }
        .scroll-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background-color: #a78bfa; /* Purple for scroll button */
            color: white;
            padding: 1rem;
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            display: none; /* Hidden by default */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, opacity 0.3s ease;
            z-index: 100;
        }
        .scroll-to-top:hover {
            background-color: #8b5cf6;
            transform: translateY(-2px);
        }
        .scroll-to-top svg {
            width: 1.5rem;
            height: 1.5rem;
        }
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .content-wrapper {
                padding: 1.5rem 1rem;
                margin: 0 0.5rem;
            }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.75rem; }
            h3 { font-size: 1.5rem; }
            .back-button {
                top: 1rem;
                left: 1rem;
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
            .back-button svg {
                width: 1rem;
                height: 1rem;
            }
            .scroll-to-top {
                bottom: 1.5rem;
                right: 1.5rem;
                padding: 0.75rem;
            }
            .scroll-to-top svg {
                width: 1.25rem;
                height: 1.25rem;
            }
            .copy-button {
                padding: 0.3rem 0.6rem;
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
     <div id="floating-share-btn" class="fixed bottom-6 left-6 z-[120] flex flex-col items-center space-y-2 group">
    <button id="main-share-btn"
    class="w-14 h-14 rounded-full bg-blue-600 shadow-xl flex items-center justify-center hover:bg-blue-700 transition duration-300 border-4 border-white dark:border-gray-800 focus:outline-none focus:ring-4 focus:ring-blue-300 group"
    aria-label="Share this page">
    <!-- Replaced img with Font Awesome share-alt icon -->
    <i class="fas fa-share-alt text-white text-2xl"></i>
  </button>
  <!-- Share Options -->
  <div id="share-options"
    class="flex flex-col items-center space-y-2 opacity-0 pointer-events-none group-focus-within:opacity-100 group-focus-within:pointer-events-auto group-hover:opacity-100 group-hover:pointer-events-auto transition-opacity duration-300">
    <!-- WhatsApp -->
    <button class="share-option w-12 h-12 rounded-full bg-green-500 hover:bg-green-600 flex items-center justify-center shadow-lg transition"
      data-network="whatsapp" aria-label="Share on WhatsApp">
      <i class="fab fa-whatsapp text-white text-2xl"></i>
    </button>
    <!-- X (Twitter) -->
    <button class="share-option w-12 h-12 rounded-full bg-gray-800 hover:bg-gray-900 flex items-center justify-center shadow-lg transition"
      data-network="twitter" aria-label="Share on X (Twitter)">
      <i class="fab fa-x-twitter text-white text-2xl"></i>
    </button>
    <!-- Facebook -->
    <button class="share-option w-12 h-12 rounded-full bg-blue-700 hover:bg-blue-800 flex items-center justify-center shadow-lg transition"
      data-network="facebook" aria-label="Share on Facebook">
      <i class="fab fa-facebook-f text-white text-2xl"></i>
    </button>
    <!-- Telegram -->
    <button class="share-option w-12 h-12 rounded-full bg-cyan-500 hover:bg-cyan-600 flex items-center justify-center shadow-lg transition"
      data-network="telegram" aria-label="Share on Telegram">
      <i class="fab fa-telegram-plane text-white text-2xl"></i>
    </button>
    <!-- Copy Link -->
    <button class="share-option w-12 h-12 rounded-full bg-gray-300 hover:bg-gray-400 dark:bg-gray-700 dark:hover:bg-gray-600 flex items-center justify-center shadow-lg transition"
      data-network="copy" aria-label="Copy Link">
      <i class="fa fa-link text-gray-800 dark:text-gray-100 text-2xl"></i>
    </button>
  </div>
  <!-- Copied Tooltip -->
  <span id="share-copied-tooltip"
    class="absolute left-16 top-6 bg-gray-900 text-white text-xs rounded px-2 py-1 shadow opacity-0 pointer-events-none transition-opacity duration-300">Copied!</span>
</div>

<script>
(function () {
  const mainBtn = document.getElementById('main-share-btn');
  const options = document.getElementById('share-options');
  const tooltip = document.getElementById('share-copied-tooltip');
  let optionsOpen = false;

  // Accessibility: open with keyboard and toggle
  mainBtn.addEventListener('click', () => {
    optionsOpen = !optionsOpen;
    options.style.opacity = optionsOpen ? '1' : '0';
    options.style.pointerEvents = optionsOpen ? 'auto' : 'none';
  });

  // Hide options when clicking outside
  document.addEventListener('click', (e) => {
    if (!mainBtn.contains(e.target) && !options.contains(e.target)) {
      optionsOpen = false;
      options.style.opacity = '0';
      options.style.pointerEvents = 'none';
    }
  });

  // Share logic
  const shareBtns = document.querySelectorAll('.share-option');
  const pageUrl = encodeURIComponent(window.location.href);
  const pageTitle = encodeURIComponent(document.title);

  shareBtns.forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      const network = btn.dataset.network;
      let shareLink = '';
      if (network === 'whatsapp') {
        shareLink = `https://wa.me/?text=${pageTitle}%20${pageUrl}`;
        window.open(shareLink, '_blank');
      } else if (network === 'twitter') {
        shareLink = `https://twitter.com/intent/tweet?text=${pageTitle}&url=${pageUrl}`;
        window.open(shareLink, '_blank');
      } else if (network === 'facebook') {
        shareLink = `https://www.facebook.com/sharer/sharer.php?u=${pageUrl}`;
        window.open(shareLink, '_blank');
      } else if (network === 'telegram') {
        shareLink = `https://t.me/share/url?url=${pageUrl}&text=${pageTitle}`;
        window.open(shareLink, '_blank');
      } else if (network === 'copy') {
        // Using document.execCommand('copy') for broader compatibility within iframes
        const tempInput = document.createElement('textarea');
        tempInput.value = window.location.href;
        document.body.appendChild(tempInput);
        tempInput.select();
        document.execCommand('copy');
        document.body.removeChild(tempInput);

        // Show tooltip
        tooltip.style.opacity = '1';
        setTimeout(() => {
          tooltip.style.opacity = '0';
        }, 1200);
      }
      optionsOpen = false;
      options.style.opacity = '0';
      options.style.pointerEvents = 'none';
    });
  });
})();
</script>

    <!-- Three.js Background Canvas -->
    <canvas id="three-bg"></canvas>

    <!-- Back Button -->
    <a href="index.html" class="back-button">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
        </svg>
        Back to Home
    </a>

    <div class="content-wrapper">
        <header class="text-center mb-10">
            <h1 class="text-5xl md:text-6xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 mb-4 animate-pulse">
                Whizmath
            </h1>
            <h1 class="text-4xl md:text-5xl font-extrabold mb-4 leading-tight">
                Data Structures & Algorithms
            </h1>
            <p class="text-xl md:text-2xl text-gray-400">
                Master fundamental data structures and efficient algorithms. <br class="hidden md:block">
                A Comprehensive Guide from Beginner to Intermediate.
            </p>
        </header>

        <section class="intro mb-12">
            <h2 class="text-3xl font-bold mb-6">Introduction to DS&A</h2>
            <p>
                In the realm of computer science, Data Structures & Algorithms (DS&A) are not just theoretical concepts; they are the bedrock upon which efficient and scalable software is built. For anyone aspiring to write robust code, optimize performance, or even understand the complexities of mathematical computing, a solid grasp of DS&A is indispensable. Think of data structures as organized ways to store and manage data, much like how a mathematician might choose the right set of equations to represent a problem. Algorithms, on the other hand, are step-by-step procedures to solve problems, akin to the precise calculations a mathematician performs.
            </p>
            <p>
                This comprehensive lesson, tailored for beginners and intermediate learners, will demystify these core concepts. We will explore how choosing the right data structure can dramatically improve an algorithm's efficiency, transforming slow, cumbersome operations into lightning-fast computations. For a math-oriented mind, understanding DS&A is akin to learning the optimal methods for solving complex equations – it's about efficiency, elegance, and provable correctness.
            </p>
            <p>
                By the end of this guide, you will have a foundational understanding of common data structures like arrays, linked lists, trees, and graphs, and essential algorithms for searching, sorting, and traversing these structures. You'll also learn the crucial concept of "Big O" notation, a mathematical way to describe the performance characteristics of algorithms, helping you analyze and compare their efficiency.
            </p>
        </section>

        <section class="big-o mb-12">
            <h2 class="text-3xl font-bold mb-6">Understanding Big O Notation: The Language of Efficiency</h2>
            <p>
                Before diving into specific data structures and algorithms, it's crucial to understand how we measure their performance. This is where Big O notation comes in. Big O notation (often written as O()) is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. In computer science, it's used to classify algorithms according to how their running time or space requirements grow as the input size grows. It describes the "worst-case scenario" complexity, giving us an upper bound on an algorithm's resource usage.
            </p>
            <p>
                Ignoring constant factors and lower-order terms, Big O helps us focus on the fundamental growth rate.
            </p>
            <h3 class="text-2xl font-bold mb-4">Common Big O Complexities:</h3>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>O(1) - Constant Time:</strong> The execution time or space required does not depend on the input size. Example: Accessing an element in an array by its index.</li>
                <li><strong>O(log n) - Logarithmic Time:</strong> The execution time grows logarithmically with the input size. Typically occurs when the problem size is halved in each step. Example: Binary Search.</li>
                <li><strong>O(n) - Linear Time:</strong> The execution time or space grows linearly with the input size. Example: Iterating through an array, Linear Search.</li>
                <li><strong>O(n log n) - Linearithmic Time:</strong> Common in efficient sorting algorithms. Example: Merge Sort, Quick Sort.</li>
                <li><strong>O(n^2) - Quadratic Time:</strong> The execution time grows quadratically with the input size. Often involves nested loops. Example: Bubble Sort, Selection Sort.</li>
                <li><strong>O(2^n) - Exponential Time:</strong> The execution time doubles with each additional input. Very inefficient for larger inputs. Example: Naive recursive Fibonacci.</li>
                <li><strong>O(n!) - Factorial Time:</strong> Extremely inefficient, grows very rapidly. Example: Solving the Traveling Salesperson Problem using brute force.</li>
            </ul>
            <p>
                When evaluating algorithms, we generally aim for lower Big O complexities. O(1) is best, followed by O(log n), O(n), O(n log n), and so on. Understanding Big O is your first step to becoming an algorithm efficiency expert.
            </p>
        </section>

        <section class="data-structures mb-12">
            <h2 class="text-3xl font-bold mb-6">Part 1: Fundamental Data Structures</h2>
            <p>
                Data structures are specialized formats for organizing and storing data in a way that enables efficient access and modification. Let's explore the most fundamental ones.
            </p>

            <h3 class="text-2xl font-bold mb-4">1. Arrays</h3>
            <p>
                An array is one of the simplest and most fundamental data structures. It's a collection of items stored at contiguous memory locations. The idea is to store multiple items of the same type together. Each item is identified by an index, typically starting from 0.
            </p>
            <h4 class="text-xl font-bold mb-3">Key Characteristics:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Fixed Size (typically):</strong> In many languages, arrays have a fixed size defined at creation. Dynamic arrays (like JavaScript arrays or Python lists) overcome this by resizing internally.</li>
                <li><strong>Contiguous Memory:</strong> Elements are stored side-by-side in memory, allowing for very fast access.</li>
                <li><strong>Indexed Access:</strong> Elements can be accessed directly using their index in O(1) time.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Common Operations & Complexities:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Access (by index):</strong> O(1) - Extremely fast.</li>
                <li><strong>Search (Linear):</strong> O(n) - Must check every element in worst case.</li>
                <li><strong>Insertion/Deletion (at end):</strong> O(1) - If space available and no shifting needed.</li>
                <li><strong>Insertion/Deletion (at beginning/middle):</strong> O(n) - Requires shifting all subsequent elements.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">When to Use Arrays:</h4>
            <p>
                When you need fast, direct access to elements and the size of the collection is known or doesn't change frequently. Ideal for mathematical matrices or fixed-size datasets.
            </p>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Array Declaration and Access
myArray = [10, 20, 30, 40, 50]

// Accessing elements
firstElement = myArray[0] // 10
thirdElement = myArray[2] // 30

// Modifying an element
myArray[1] = 25 // myArray is now [10, 25, 30, 40, 50]

// Iterating
for element in myArray:
    print(element)</code></pre>
            </div>

            <h3 class="text-2xl font-bold mb-4">2. Linked Lists</h3>
            <p>
                A linked list is a linear data structure, like an array, but elements are not stored at contiguous memory locations. Instead, elements are linked using pointers. Each element (called a "node") consists of two parts: the data and a pointer (or reference) to the next node in the sequence.
            </p>
            <h4 class="text-xl font-bold mb-3">Types of Linked Lists:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Singly Linked List:</strong> Each node points only to the next node.</li>
                <li><strong>Doubly Linked List:</strong> Each node has pointers to both the next and the previous node.</li>
                <li><strong>Circular Linked List:</strong> The last node points back to the first node, forming a circle.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Key Characteristics:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Dynamic Size:</strong> Can grow or shrink at runtime.</li>
                <li><strong>Non-contiguous Memory:</strong> Nodes can be anywhere in memory.</li>
                <li><strong>Sequential Access:</strong> To access an element, you must traverse from the beginning (or end for doubly linked lists).</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Common Operations & Complexities:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Access (by index):</strong> O(n) - Requires traversal.</li>
                <li><strong>Search:</strong> O(n) - Requires traversal.</li>
                <li><strong>Insertion/Deletion (at beginning):</strong> O(1) - Just change the head pointer.</li>
                <li><strong>Insertion/Deletion (at middle/end):</strong> O(n) - Requires finding the position first (traversal).</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">When to Use Linked Lists:</h4>
            <p>
                When frequent insertions and deletions are needed, especially at the ends or if the data size is highly variable. Useful for implementing stacks and queues.
            </p>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual - Singly Linked List Node):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Node Structure for Singly Linked List
class Node:
    data
    next_node // reference to the next Node

// Creating a simple linked list: 1 -> 2 -> 3 -> null
node1 = new Node(1)
node2 = new Node(2)
node3 = new Node(3)

node1.next_node = node2
node2.next_node = node3
// head of the list is node1</code></pre>
            </div>

            <h3 class="text-2xl font-bold mb-4">3. Stacks</h3>
            <p>
                A stack is a linear data structure that follows a particular order in which operations are performed. The order is LIFO (Last In, First Out). Think of a stack of plates: you can only add a new plate to the top, and you can only remove the topmost plate.
            </p>
            <h4 class="text-xl font-bold mb-3">Key Operations:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Push:</strong> Adds an item to the top of the stack.</li>
                <li><strong>Pop:</strong> Removes the top item from the stack.</li>
                <li><strong>Peek/Top:</strong> Returns the top item without removing it.</li>
                <li><strong>isEmpty:</strong> Checks if the stack is empty.</li>
                <li><strong>Size:</strong> Returns the number of items in the stack.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Common Operations & Complexities:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li>All operations (Push, Pop, Peek, isEmpty) are O(1) - very efficient.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">When to Use Stacks:</h4>
            <p>
                For tasks requiring undo/redo functionality, function call management (call stack), expression evaluation, and backtracking algorithms (e.g., maze solving).
            </p>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Stack Operations
Stack myStack = new Stack()

myStack.push(10)  // Stack: [10]
myStack.push(20)  // Stack: [10, 20]
myStack.push(30)  // Stack: [10, 20, 30]

topElement = myStack.peek() // 30
removedElement = myStack.pop() // 30, Stack: [10, 20]
isEmpty = myStack.isEmpty() // false
myStack.pop() // 20, Stack: [10]
myStack.pop() // 10, Stack: []
isEmpty = myStack.isEmpty() // true</code></pre>
            </div>

            <h3 class="text-2xl font-bold mb-4">4. Queues</h3>
            <p>
                A queue is a linear data structure that follows a particular order: FIFO (First In, First Out). Think of a line at a ticket counter: the first person in line is the first person to be served.
            </p>
            <h4 class="text-xl font-bold mb-3">Key Operations:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Enqueue (or Offer):</strong> Adds an item to the rear (back) of the queue.</li>
                <li><strong>Dequeue (or Poll):</strong> Removes the front item from the queue.</li>
                <li><strong>Front/Peek:</strong> Returns the front item without removing it.</li>
                <li><strong>isEmpty:</strong> Checks if the queue is empty.</li>
                <li><strong>Size:</strong> Returns the number of items in the queue.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Common Operations & Complexities:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li>All operations (Enqueue, Dequeue, Peek, isEmpty) are O(1) - very efficient.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">When to Use Queues:</h4>
            <p>
                For managing tasks in a specific order (e.g., print spoolers, CPU scheduling, bread-first search algorithms).
            </p>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Queue Operations
Queue myQueue = new Queue()

myQueue.enqueue("Task A") // Queue: ["Task A"]
myQueue.enqueue("Task B") // Queue: ["Task A", "Task B"]
myQueue.enqueue("Task C") // Queue: ["Task A", "Task B", "Task C"]

frontTask = myQueue.peek() // "Task A"
processedTask = myQueue.dequeue() // "Task A", Queue: ["Task B", "Task C"]
isEmpty = myQueue.isEmpty() // false
myQueue.dequeue() // "Task B", Queue: ["Task C"]
myQueue.dequeue() // "Task C", Queue: []
isEmpty = myQueue.isEmpty() // true</code></pre>
            </div>

            <h3 class="text-2xl font-bold mb-4">5. Trees</h3>
            <p>
                Trees are non-linear, hierarchical data structures. They consist of nodes connected by edges, resembling an inverted tree. The topmost node is called the "root." Each node can have zero or more "child" nodes, and each child node has exactly one "parent" node (except the root).
            </p>
            <h4 class="text-xl font-bold mb-3">Key Terminology:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Root:</strong> The top-most node of a tree.</li>
                <li><strong>Child:</strong> A node directly connected to another node when moving away from the Root.</li>
                <li><strong>Parent:</strong> The converse notion of a child.</li>
                <li><strong>Leaf Node:</strong> A node with no children.</li>
                <li><strong>Edge:</strong> The connection between two nodes.</li>
                <li><strong>Path:</strong> A sequence of nodes along the edges of a tree.</li>
                <li><strong>Depth:</strong> The length of the path from the root to the node.</li>
                <li><strong>Height:</strong> The length of the longest path from the node to a leaf.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Binary Trees:</h4>
            <p>
                A special type of tree where each node has at most two children, typically referred to as the left child and the right child.
            </p>
            <h4 class="text-xl font-bold mb-3">Binary Search Trees (BSTs):</h4>
            <p>
                A Binary Tree with an additional property: for every node, all values in its left subtree are less than the node's value, and all values in its right subtree are greater than the node's value. This property makes searching, insertion, and deletion very efficient on average.
            </p>
            <h4 class="text-xl font-bold mb-3">Common Operations & Complexities (BST):</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Search:</strong> O(log n) on average (balanced tree), O(n) in worst case (skewed tree).</li>
                <li><strong>Insertion:</strong> O(log n) on average, O(n) in worst case.</li>
                <li><strong>Deletion:</strong> O(log n) on average, O(n) in worst case.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">When to Use Trees (BSTs):</h4>
            <p>
                When data needs to be stored hierarchically, or when efficient searching, insertion, and deletion are required while maintaining sorted order (e.g., database indexing, file systems).
            </p>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual - BST Node):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Node Structure for Binary Search Tree
class TreeNode:
    value
    left_child // reference to left TreeNode
    right_child // reference to right TreeNode

// Example BST structure:
//        50
//       /  \
//      30   70
//     / \   / \
//    20 40 60 80

// Pseudocode for inserting into a BST
function insert(root, value):
    if root is null:
        return new TreeNode(value)
    if value < root.value:
        root.left_child = insert(root.left_child, value)
    else: // value >= root.value
        root.right_child = insert(root.right_child, value)
    return root</code></pre>
            </div>

            <h3 class="text-2xl font-bold mb-4">6. Graphs</h3>
            <p>
                A graph is a non-linear data structure consisting of a finite set of "vertices" (or nodes) and a set of "edges" that connect pairs of vertices. Unlike trees, graphs can have arbitrary connections between nodes, including cycles.
            </p>
            <h4 class="text-xl font-bold mb-3">Key Terminology:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Vertex (Node):</strong> The fundamental entity of a graph.</li>
                <li><strong>Edge:</strong> A connection between two vertices.</li>
                <li><strong>Directed Graph:</strong> Edges have a direction (e.g., one-way street).</li>
                <li><strong>Undirected Graph:</strong> Edges have no direction (e.g., two-way street).</li>
                <li><strong>Weighted Graph:</strong> Edges have an associated numerical value (weight/cost).</li>
                <li><strong>Cycle:</strong> A path that starts and ends at the same vertex.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Representations of Graphs:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Adjacency Matrix:</strong> A 2D array where `matrix[i][j]` is 1 if there's an edge from vertex `i` to `j`, and 0 otherwise (or weight for weighted graphs). Good for dense graphs. Space: O(V^2).</li>
                <li><strong>Adjacency List:</strong> An array of lists (or hash maps) where `adj[i]` contains a list of all vertices adjacent to vertex `i`. Good for sparse graphs. Space: O(V + E) where E is number of edges.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">When to Use Graphs:</h4>
            <p>
                To model relationships and networks. Examples include social networks, transportation networks, routing algorithms, and dependencies in tasks.
            </p>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual - Adjacency List):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Adjacency List Representation
// Graph: A -- B
//        |    |
//        C -- D

// Representation:
// AdjacencyList = {
//   'A': ['B', 'C'],
//   'B': ['A', 'D'],
//   'C': ['A', 'D'],
//   'D': ['B', 'C']
// }

class Graph:
    vertices // a list or set of vertex objects
    adjacency_list // a map: vertex -> list of connected vertices

    function addEdge(u, v):
        adjacency_list[u].add(v)
        adjacency_list[v].add(u) // For undirected graph</code></pre>
            </div>

            <h3 class="text-2xl font-bold mb-4">7. Hash Tables (Hash Maps / Dictionaries)</h3>
            <p>
                A hash table is a data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. This allows for very fast average-case access time.
            </p>
            <h4 class="text-xl font-bold mb-3">Key Concepts:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Key-Value Pairs:</strong> Stores data as pairs, where each unique key maps to a specific value.</li>
                <li><strong>Hash Function:</strong> A function that converts an input (key) into a fixed-size numerical value (hash code or index). A good hash function distributes keys evenly.</li>
                <li><strong>Collision:</strong> When two different keys produce the same hash code.</li>
                <li><strong>Collision Resolution:</strong> Techniques to handle collisions (e.g., Separate Chaining using linked lists, Open Addressing like linear probing).</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Common Operations & Complexities:</h4>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Insertion, Deletion, Search:</strong> O(1) on average.</li>
                <li><strong>Worst Case:</strong> O(n) (e.g., all keys hash to the same bucket).</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">When to Use Hash Tables:</h4>
            <p>
                When you need extremely fast lookups, insertions, and deletions based on a key. Common uses include database indexing, caching, frequency counting, and symbol tables in compilers.
            </p>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Hash Table Operations
HashTable myMap = new HashTable()

// Insertion
myMap.put("apple", 5)
myMap.put("banana", 10)
myMap.put("cherry", 15)

// Retrieval
value1 = myMap.get("apple") // 5
value2 = myMap.get("grape") // null or undefined

// Deletion
myMap.remove("banana") // Removes "banana": 10

// Check existence
hasCherry = myMap.containsKey("cherry") // true</code></pre>
            </div>
        </section>

        <section class="algorithms mb-12">
            <h2 class="text-3xl font-bold mb-6">Part 2: Essential Algorithms</h2>
            <p>
                Algorithms are precise sequences of instructions used to solve a problem or perform a computation. They are the "recipes" that operate on data structures.
            </p>

            <h3 class="text-2xl font-bold mb-4">1. Searching Algorithms</h3>
            <p>
                Searching algorithms are used to find an element or retrieve information from a data structure.
            </p>
            <h4 class="text-xl font-bold mb-3">a. Linear Search (Sequential Search)</h4>
            <p>
                The simplest searching algorithm. It sequentially checks each element of the list until a match is found or the end of the list is reached.
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Complexity:</strong> O(n) in worst case (element not found or at the end).</li>
                <li><strong>Use Case:</strong> For unsorted lists or very small lists.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Linear Search
function linearSearch(array, target):
    for i from 0 to array.length - 1:
        if array[i] == target:
            return i // Return index if found
    return -1 // Return -1 if not found

numbers = [5, 2, 8, 1, 9]
foundIndex = linearSearch(numbers, 8) // Returns 2
notFoundIndex = linearSearch(numbers, 7) // Returns -1</code></pre>
            </div>

            <h4 class="text-xl font-bold mb-3">b. Binary Search</h4>
            <p>
                A highly efficient searching algorithm that works on sorted arrays. It repeatedly divides the search interval in half. If the value of the search key is less than the item in the middle of the interval, the interval is narrowed to the lower half. Otherwise, it is narrowed to the upper half.
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Pre-requisite:</strong> Array must be sorted.</li>
                <li><strong>Complexity:</strong> O(log n) - Very efficient for large datasets.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Binary Search (Iterative)
function binarySearch(sortedArray, target):
    low = 0
    high = sortedArray.length - 1

    while low <= high:
        mid = floor((low + high) / 2)
        if sortedArray[mid] == target:
            return mid // Target found
        else if sortedArray[mid] < target:
            low = mid + 1 // Search in right half
        else:
            high = mid - 1 // Search in left half
    return -1 // Target not found

sortedNumbers = [1, 2, 5, 8, 9]
foundIndex = binarySearch(sortedNumbers, 5) // Returns 2
notFoundIndex = binarySearch(sortedNumbers, 7) // Returns -1</code></pre>
            </div>

            <h3 class="text-2xl font-bold mb-4">2. Sorting Algorithms</h3>
            <p>
                Sorting algorithms arrange elements of a list in a certain order (ascending or descending).
            </p>
            <h4 class="text-xl font-bold mb-3">a. Bubble Sort</h4>
            <p>
                A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. It's named for the way smaller or larger elements "bubble" to the top of the list.
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Complexity:</strong> O(n^2) - Inefficient for large datasets.</li>
                <li><strong>Stability:</strong> Stable (preserves relative order of equal elements).</li>
                <li><strong>In-place:</strong> Yes (requires minimal extra space).</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Bubble Sort
function bubbleSort(array):
    n = array.length
    for i from 0 to n-2:
        swapped = false
        for j from 0 to n-i-2:
            if array[j] > array[j+1]:
                // Swap array[j] and array[j+1]
                temp = array[j]
                array[j] = array[j+1]
                array[j+1] = temp
                swapped = true
        if not swapped:
            break // If no swaps in a pass, array is sorted
    return array

numbers = [64, 34, 25, 12, 22, 11, 90]
sortedNumbers = bubbleSort(numbers) // [11, 12, 22, 25, 34, 64, 90]</code></pre>
            </div>

            <h4 class="text-xl font-bold mb-3">b. Merge Sort</h4>
            <p>
                A highly efficient, comparison-based sorting algorithm. It works on the principle of "divide and conquer." It divides the unsorted list into n sublists, each containing one element (a list of one element is considered sorted). Then, it repeatedly merges sublists to produce new sorted sublists until there is only one sorted list remaining.
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Complexity:</strong> O(n log n) - Excellent for large datasets.</li>
                <li><strong>Stability:</strong> Stable.</li>
                <li><strong>In-place:</strong> No (requires O(n) auxiliary space).</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Merge Sort
function mergeSort(array):
    if array.length <= 1:
        return array

    mid = floor(array.length / 2)
    left_half = array[0 to mid-1]
    right_half = array[mid to array.length-1]

    sorted_left = mergeSort(left_half)
    sorted_right = mergeSort(right_half)

    return merge(sorted_left, sorted_right)

function merge(left, right):
    result = []
    i = 0, j = 0

    while i < left.length AND j < right.length:
        if left[i] <= right[j]:
            result.add(left[i])
            i++
        else:
            result.add(right[j])
            j++

    // Add remaining elements
    while i < left.length:
        result.add(left[i])
        i++
    while j < right.length:
        result.add(right[j])
        j++

    return result

numbers = [38, 27, 43, 3, 9, 82, 10]
sortedNumbers = mergeSort(numbers) // [3, 9, 10, 27, 38, 43, 82]</code></pre>
            </div>

            <h4 class="text-xl font-bold mb-3">c. Quick Sort</h4>
            <p>
                Another efficient, comparison-based sorting algorithm that also uses the "divide and conquer" paradigm. It picks an element as a pivot and partitions the given array around the picked pivot. All elements smaller than the pivot come before it, and all greater elements come after it. This process is then recursively applied to the sub-arrays.
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Complexity:</strong> O(n log n) on average, O(n^2) in worst case (bad pivot choices).</li>
                <li><strong>Stability:</strong> Not stable.</li>
                <li><strong>In-place:</strong> Yes (efficient in-place partitioning).</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Quick Sort
function quickSort(array, low, high):
    if low < high:
        pivot_index = partition(array, low, high)
        quickSort(array, low, pivot_index - 1)
        quickSort(array, pivot_index + 1, high)
    return array

function partition(array, low, high):
    pivot = array[high] // Choose last element as pivot
    i = low - 1 // Index of smaller element

    for j from low to high - 1:
        if array[j] <= pivot:
            i++
            // Swap array[i] and array[j]
            temp = array[i]
            array[i] = array[j]
            array[j] = temp

    // Swap array[i+1] and array[high] (pivot)
    temp = array[i+1]
    array[i+1] = array[high]
    array[high] = temp

    return i + 1

numbers = [10, 7, 8, 9, 1, 5]
// To call: quickSort(numbers, 0, numbers.length - 1)
// Result: [1, 5, 7, 8, 9, 10]</code></pre>
            </div>

            <h3 class="text-2xl font-bold mb-4">3. Graph Traversal Algorithms</h3>
            <p>
                These algorithms are used to visit all nodes in a graph systematically.
            </p>
            <h4 class="text-xl font-bold mb-3">a. Breadth-First Search (BFS)</h4>
            <p>
                BFS is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph) and explores all of the neighbor nodes at the present depth before moving on to the nodes at the next depth level. It typically uses a queue.
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Complexity:</strong> O(V + E) where V is vertices, E is edges (for Adjacency List).</li>
                <li><strong>Applications:</strong> Finding shortest path in an unweighted graph, peer-to-peer networking, web crawlers.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: BFS
function BFS(graph, start_node):
    queue = new Queue()
    visited = new Set()

    queue.enqueue(start_node)
    visited.add(start_node)

    while not queue.isEmpty():
        current_node = queue.dequeue()
        print(current_node) // Process the node

        for neighbor in graph.getNeighbors(current_node):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.enqueue(neighbor)</code></pre>
            </div>

            <h4 class="text-xl font-bold mb-3">b. Depth-First Search (DFS)</h4>
            <p>
                DFS is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root (or any arbitrary node) and explores as far as possible along each branch before backtracking. It typically uses a stack (explicitly or implicitly via recursion).
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Complexity:</strong> O(V + E) where V is vertices, E is edges (for Adjacency List).</li>
                <li><strong>Applications:</strong> Topological sorting, cycle detection, pathfinding, maze solving.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: DFS (Recursive)
function DFS(graph, start_node, visited):
    visited.add(start_node)
    print(start_node) // Process the node

    for neighbor in graph.getNeighbors(start_node):
        if neighbor not in visited:
            DFS(graph, neighbor, visited)

// Initial call:
// visited_set = new Set()
// DFS(myGraph, "A", visited_set)</code></pre>
            </div>
        </section>

        <section class="recursion mb-12">
            <h2 class="text-3xl font-bold mb-6">Part 3: Recursion & Advanced Concepts (Brief)</h2>
            <h3 class="text-2xl font-bold mb-4">1. Recursion</h3>
            <p>
                Recursion is a technique where a function calls itself directly or indirectly to solve a problem. It breaks down a problem into smaller, identical subproblems. Every recursive function needs a base case (a condition under which the function stops calling itself) to prevent infinite loops.
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Analogy:</strong> Think of Russian nesting dolls, where each doll contains a smaller version of itself until you reach the smallest one.</li>
                <li><strong>Mathematical Connection:</strong> Many mathematical functions, like factorial or Fibonacci sequences, have natural recursive definitions.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual - Factorial):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Factorial using Recursion
function factorial(n):
    // Base Case: If n is 0 or 1, factorial is 1
    if n == 0 or n == 1:
        return 1
    // Recursive Step: n! = n * (n-1)!
    else:
        return n * factorial(n - 1)

// factorial(5) calculates:
// 5 * factorial(4)
// 5 * (4 * factorial(3))
// 5 * (4 * (3 * factorial(2)))
// 5 * (4 * (3 * (2 * factorial(1))))
// 5 * (4 * (3 * (2 * 1))) = 120</code></pre>
            </div>

            <h3 class="text-2xl font-bold mb-4">2. Dynamic Programming (DP)</h3>
            <p>
                Dynamic Programming is an optimization technique used to solve complex problems by breaking them down into simpler subproblems. It solves each subproblem only once and stores its solution, so that it doesn't have to recompute them later. This is particularly useful for problems with "overlapping subproblems" and "optimal substructure."
            </p>
            <p>
                It's often seen as recursion with memoization (storing results of expensive function calls and returning the cached result when the same inputs occur again) or iterative bottom-up approaches.
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Key Idea:</strong> Avoid redundant calculations.</li>
                <li><strong>Applications:</strong> Fibonacci sequence, shortest path problems, knapsack problem, string algorithms.</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual - Fibonacci with Memoization):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Fibonacci using Dynamic Programming (Memoization)
// F(n) = F(n-1) + F(n-2)
// F(0) = 0, F(1) = 1

memo = an empty map/dictionary

function fibonacci(n):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n

    result = fibonacci(n - 1) + fibonacci(n - 2)
    memo[n] = result
    return result

// fibonacci(5) will compute fib(3) and fib(2) only once,
// even though they are called multiple times in a naive recursive approach.</code></pre>
            </div>

            <h3 class="text-2xl font-bold mb-4">3. Greedy Algorithms</h3>
            <p>
                A greedy algorithm is an algorithmic paradigm that follows the problem-solving heuristic of making the locally optimal choice at each stage with the hope of finding a global optimum. In many problems, a greedy strategy does not produce an optimal solution, but in some problems, it does.
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Characteristic:</strong> Makes choices that look best at the moment, without considering future implications.</li>
                <li><strong>Applications:</strong> Coin change problem (in some currency systems), Dijkstra's algorithm (for shortest paths), Prim's/Kruskal's (for minimum spanning trees).</li>
            </ul>
            <h4 class="text-xl font-bold mb-3">Example (Conceptual - Coin Change, US Currency):</h4>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
<pre><code>// Pseudocode: Greedy Coin Change (for US coins: 25, 10, 5, 1 cents)
function makeChange(amount):
    coins = [25, 10, 5, 1] // Sorted in descending order
    result = {} // Stores count of each coin
    
    for coin in coins:
        while amount >= coin:
            if coin not in result:
                result[coin] = 0
            result[coin] = result[coin] + 1
            amount = amount - coin
            
    return result

// makeChange(67) will produce: {25: 2, 10: 1, 5: 1, 1: 2}
// (2 quarters, 1 dime, 1 nickel, 2 pennies)</code></pre>
            </div>
        </section>

        <section class="conclusion mb-12">
            <h2 class="text-3xl font-bold mb-6">Conclusion & Next Steps</h2>
            <p>
                Congratulations on completing this comprehensive journey through the fundamentals of Data Structures and Algorithms! You've learned about how data is organized, how to efficiently search and sort it, and explored powerful algorithmic paradigms like recursion, dynamic programming, and greedy approaches. This knowledge is not just theoretical; it's the foundation for solving real-world computational problems, optimizing software performance, and excelling in technical interviews.
            </p>
            <p>
                As you continue your learning:
            </p>
            <ul class="list-disc list-inside ml-4 mb-4">
                <li><strong>Practice, Practice, Practice:</strong> The best way to solidify your understanding is by solving problems. Websites like LeetCode, HackerRank, and Advent of Code offer countless DS&A challenges.</li>
                <li><strong>Implement:</strong> Try implementing these data structures and algorithms yourself in your preferred programming language. The act of writing the code deepens comprehension.</li>
                <li><strong>Explore More:</strong> Dive deeper into advanced topics like self-balancing trees (AVL, Red-Black Trees), Tries, Fenwick Trees, Suffix Arrays, network flow algorithms, and more complex graph algorithms (e.g., shortest paths with negative weights, maximum flow).</li>
                <li><strong>Analyze Real-World Use Cases:</strong> Think about how DS&A are used in databases, operating systems, artificial intelligence, and scientific computing.</li>
            </ul>
            <p>
                Remember, DS&A is a continuous learning process. The more you explore, the more you'll appreciate the elegance and power they bring to problem-solving. Happy coding, and keep whizzing with math!
            </p>
        </section>

        <footer class="text-center text-gray-500 text-sm mt-12 pt-8 border-t border-gray-700">
            &copy; 2025 Whizmath. All rights reserved.
        </footer>
    </div>

    <!-- Scroll to Top Button -->
    <button id="scrollToTopBtn" class="scroll-to-top">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
        </svg>
    </button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js Background Animation
        window.onload = function() {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-bg'), antialias: true });

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0d1117, 1); // Match body background

            // Particles
            const particleCount = 2500; // Increased particle count for more density
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 250; // Increased spread
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: 0x63b3ed, // Blueish color
                size: 1.5, // Increased particle size
                transparent: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const particleMesh = new THREE.Points(particles, particleMaterial);
            scene.add(particleMesh);

            // Lines connecting particles
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xa78bfa, // Purplish color
                transparent: true,
                opacity: 0.25 // Increased line opacity
            });
            const lineGeometry = new THREE.BufferGeometry();
            const linePositions = new Float32Array(particleCount * 3 * 2); // Each line connects two points

            // Simple logic to connect close particles
            const threshold = 20; // Increased max distance for connection, leading to more lines
            let lineIndex = 0;
            for (let i = 0; i < particleCount; i++) {
                for (let j = i + 1; j < particleCount; j++) {
                    const x1 = positions[i * 3];
                    const y1 = positions[i * 3 + 1];
                    const z1 = positions[i * 3 + 2];

                    const x2 = positions[j * 3];
                    const y2 = positions[j * 3 + 1];
                    const z2 = positions[j * 3 + 2];

                    const dx = x1 - x2;
                    const dy = y1 - y2;
                    const dz = z1 - z2;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (distance < threshold) {
                        linePositions[lineIndex++] = x1;
                        linePositions[lineIndex++] = y1;
                        linePositions[lineIndex++] = z1;

                        linePositions[lineIndex++] = x2;
                        linePositions[lineIndex++] = y2;
                        linePositions[lineIndex++] = z2;
                    }
                }
            }

            lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions.slice(0, lineIndex), 3));
            const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(lines);


            camera.position.z = 100;

            let mouseX = 0;
            let mouseY = 0;

            function onDocumentMouseMove(event) {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            }
            document.addEventListener('mousemove', onDocumentMouseMove);

            function animate() {
                requestAnimationFrame(animate);

                // Rotate particles and lines slightly
                particleMesh.rotation.x += 0.0005;
                particleMesh.rotation.y += 0.0007;

                lines.rotation.x += 0.0005;
                lines.rotation.y += 0.0007;

                // Make camera slowly follow mouse
                camera.position.x += (mouseX * 50 - camera.position.x) * 0.01;
                camera.position.y += (mouseY * 50 - camera.position.y) * 0.01;
                camera.lookAt(scene.position);


                renderer.render(scene, camera);
            }
            animate();

            // Handle window resizing
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        };

        // Scroll to Top Button Logic
        const scrollToTopBtn = document.getElementById("scrollToTopBtn");

        // When the user scrolls down 200px from the top of the document, show the button
        window.onscroll = function() {
            if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
                scrollToTopBtn.style.display = "block";
                scrollToTopBtn.style.opacity = "1";
            } else {
                scrollToTopBtn.style.opacity = "0";
                setTimeout(() => { // Give time for transition before hiding
                    if (document.body.scrollTop <= 200 && document.documentElement.scrollTop <= 200) {
                        scrollToTopBtn.style.display = "none";
                    }
                }, 300);
            }
        };

        // When the user clicks on the button, scroll to the top of the document
        scrollToTopBtn.addEventListener("click", () => {
            window.scrollTo({
                top: 0,
                behavior: "smooth"
            });
        });

        // Code Copy Functionality
        function copyCode(button) {
            const codeBlock = button.nextElementSibling; // Get the <pre> tag
            const code = codeBlock.textContent || codeBlock.innerText; // Get the code text

            // Create a temporary textarea element to copy the text
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = code;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();

            try {
                const successful = document.execCommand('copy');
                const msg = successful ? 'Copied!' : 'Failed to copy.';
                button.textContent = msg; // Change button text
                setTimeout(() => {
                    button.textContent = 'Copy Code'; // Revert button text
                }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
                button.textContent = 'Error!';
                setTimeout(() => {
                    button.textContent = 'Copy Code';
                }, 2000);
            } finally {
                document.body.removeChild(tempTextArea); // Clean up
            }
        }
    </script>
</body>
</html>
