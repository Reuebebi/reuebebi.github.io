<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust Programming: Beginner to Intermediate Course - Whizmath</title>
    <meta name="description" content="Explore Rust, a language for performance, reliability, and safety, ideal for systems programming. Learn fundamentals, ownership, concurrency, and build robust applications with Whizmath.">
    <meta name="keywords" content="Rust Programming, Rust Lang, Learn Rust, Rust tutorial, systems programming, performance, reliability, memory safety, ownership, borrowing, lifetimes, concurrency, web assembly, Whizmath, beginner, intermediate, programming language">
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font from Google Fonts -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background similar to GitHub */
            color: #c9d1d9; /* Light text for contrast */
            overflow-x: hidden; /* Prevent horizontal scroll */
        }
        
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            opacity: 0.2; /* Subtle background */
        }

        /* Custom scrollbar for a sleek look */
        ::-webkit-scrollbar {
            width: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #1a202c; /* Darker track */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* Greyish thumb */
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* Lighter on hover */
        }

        .code-block-container {
            position: relative;
            background-color: #161b22; /* Darker background for code blocks */
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            overflow-x: auto; /* Enable horizontal scrolling for wide code */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); /* Subtle shadow */
        }

        .code-block-container pre {
            margin: 0;
            padding: 0;
            white-space: pre-wrap; /* Wrap long lines */
            word-break: break-all; /* Break words if necessary */
        }

        .code-block-container code {
            font-family: 'Fira Code', 'Cascadia Code', monospace; /* Monospaced font for code */
            color: #58a6ff; /* Light blue for code */
            display: block; /* Ensure code takes full width */
        }

        .copy-button {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            padding: 0.5rem 1rem;
            background-color: #374151; /* Dark grey */
            color: #d1d5db; /* Light grey text */
            border-radius: 0.375rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border: none;
            outline: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .copy-button:hover {
            background-color: #4b5563; /* Lighter dark grey on hover */
        }

        .copy-button:active {
            background-color: #1f2937; /* Even darker on click */
        }

        .copy-button i {
            margin-right: 0.25rem;
        }

        .back-button {
            position: fixed;
            top: 2rem;
            left: 2rem;
            z-index: 50; /* Ensure it's above content */
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background-color: #4f46e5; /* Indigo */
            color: white;
            border-radius: 9999px; /* Fully rounded */
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 4px 14px rgba(79, 70, 229, 0.3);
        }

        .back-button:hover {
            background-color: #4338ca; /* Darker indigo */
            transform: translateX(-5px); /* Subtle slide effect */
            box-shadow: 0 6px 20px rgba(79, 70, 229, 0.4);
        }

        .scroll-to-top-btn {
            display: none; /* Hidden by default */
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 99; /* Higher z-index */
            background-color: #3b82f6; /* Blue 500 */
            color: white;
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 14px rgba(59, 130, 246, 0.4); /* Blue shadow */
            cursor: pointer;
            transition: background-color 0.3s ease-in-out, transform 0.2s ease-in-out;
        }

        .scroll-to-top-btn:hover {
            background-color: #2563eb; /* Blue 600 */
            transform: translateY(-5px); /* Lift effect */
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .back-button {
                top: 1rem;
                left: 1rem;
                padding: 0.5rem 1rem;
                font-size: 0.875rem;
            }
            .scroll-to-top-btn {
                bottom: 1rem;
                right: 1rem;
                width: 3rem;
                height: 3rem;
                font-size: 1.25rem;
            }
            .main-content {
                padding: 1rem;
            }
        }
    </style>
</head>
<body class="antialiased">
    <!-- Three.js Canvas for animated background -->
    <canvas id="three-canvas"></canvas>

    <!-- Back to Programming Button -->
    <a href="programming.html" class="back-button">
        <i class="fas fa-arrow-left"></i>
        <span>Back to Programming</span>
    </a>

    <!-- Main Content Area -->
    <div class="relative z-10 min-h-screen flex flex-col items-center justify-center py-16 px-4 md:px-8 bg-gradient-to-br from-gray-900 to-black">
        <header class="text-center mb-16 max-w-4xl">
            <h1 class="text-6xl md:text-7xl font-extrabold text-white leading-tight mb-4 animate-fade-in-down">
                <span class="text-blue-400">Whizmath</span> presents:
            </h1>
            <h2 class="text-5xl md:text-6xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-orange-500 leading-tight">
                Rust Programming
            </h2>
            <p class="text-2xl md:text-3xl text-gray-300 mt-6 animate-fade-in-up">
                Explore Rust, a language for performance, reliability, and safety.
            </p>
            <p class="text-xl text-gray-400 mt-4 max-w-2xl mx-auto">
                Ideal for systems programming, web assembly, and beyond.
            </p>
        </header>

        <main class="main-content max-w-4xl mx-auto bg-gray-800 bg-opacity-70 backdrop-blur-sm p-8 md:p-12 rounded-xl shadow-2xl space-y-10 border border-gray-700">
            <section class="mb-10">
                <h3 class="text-4xl font-bold text-teal-400 mb-6 border-b-2 border-teal-400 pb-2">
                    Introduction: The Promise of Rust - Performance Without Compromise
                </h3>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    In the intricate world of software development, a persistent challenge has been the trade-off between performance and safety. Languages like C and C++ offer unparalleled speed but demand meticulous memory management, often leading to bugs, security vulnerabilities, and crashes. On the other hand, languages like Python or JavaScript prioritize developer productivity and safety through automatic memory management (garbage collection) but at the cost of raw execution speed. This is where <strong class="text-orange-400">Rust</strong> enters the scene â€“ a systems programming language that aims to bridge this gap, offering performance comparable to C/C++ while guaranteeing memory safety and thread safety at compile time, without a garbage collector.
                </p>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Developed by Mozilla and now a community-driven project, Rust has quickly become a favorite for a wide array of applications, from operating systems and game engines to web services and embedded devices. Its unique ownership system and borrow checker eliminate entire classes of bugs before your code even runs, leading to highly reliable and robust software.
                </p>
                <p class="text-lg leading-relaxed text-gray-300">
                    This comprehensive course from Whizmath is your guide to understanding and mastering Rust. We'll start with the foundational syntax, delve deep into Rust's core concepts of ownership, borrowing, and lifetimes, and explore its powerful type system and concurrency features. Whether you're a seasoned systems programmer, a web developer curious about WebAssembly, or simply looking for a language that empowers you to write highly performant and safe code, this lesson provides a clear and engaging path. Let's unlock the full potential of Rust!
                </p>
            </section>

            <section class="mb-10">
                <h3 class="text-4xl font-bold text-purple-400 mb-6 border-b-2 border-purple-400 pb-2">
                    Part 1: Rust Fundamentals - Getting Started
                </h3>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    1.1 Setting Up Your Rust Environment
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Rust is installed and managed by a tool called <strong class="text-yellow-300">`rustup`</strong>, which simplifies installing Rust from various release channels and keeps your Rust installation up-to-date.
                </p>
                <ul class="list-disc list-inside text-lg leading-relaxed text-gray-300 pl-6 space-y-3">
                    <li>Open your terminal or command prompt.</li>
                    <li>Install `rustup` by running:</li>
                </ul>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-bash">
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
                    <p class="text-sm text-gray-400 mt-2">
                        Follow the on-screen instructions. This will download `rustup` and the latest stable version of Rust.
                    </p>
                </div>
                <ul class="list-disc list-inside text-lg leading-relaxed text-gray-300 pl-6 space-y-3">
                    <li>Verify your installation:</li>
                </ul>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-bash">
rustc --version
cargo --version
</code></pre>
                    <p class="text-sm text-gray-400 mt-2">
                        `rustc` is the Rust compiler, and `cargo` is Rust's build system and package manager.
                    </p>
                </div>
                <p class="text-lg leading-relaxed text-gray-300">
                    Rust projects are managed by <strong class="text-yellow-300">Cargo</strong>. To create a new project:
                </p>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-bash">
cargo new my_rust_project
cd my_rust_project
</code></pre>
                    <p class="text-sm text-gray-400 mt-2">
                        This creates a new directory `my_rust_project` with a `Cargo.toml` (project configuration) and a `src/main.rs` file.
                    </p>
                </div>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    1.2 "Hello, World!" in Rust
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    The `src/main.rs` file created by `cargo new` already contains the classic "Hello, World!" program:
                </p>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-rust">
fn main() {
    println!("Hello, Whizmath from Rust!");
}
</code></pre>
                    <p class="text-sm text-gray-400 mt-2">
                        To compile and run this program, use Cargo:
                    </p>
<pre><code class="language-bash">
cargo run
</code></pre>
                    <p class="text-sm text-gray-400 mt-2">
                        You should see "Hello, Whizmath from Rust!" printed to the console. Cargo handles compilation and execution.
                    </p>
                </div>
                <ul class="list-disc list-inside text-lg leading-relaxed text-gray-300 pl-6 space-y-3">
                    <li><strong class="text-blue-400">`fn main()`</strong>: The entry point function for an executable Rust program.</li>
                    <li><strong class="text-blue-400">`println!`</strong>: A Rust <strong class="text-yellow-300">macro</strong> that prints text to the console. Macros are similar to functions but are expanded at compile time.</li>
                </ul>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    1.3 Variables and Data Types
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Rust is also a statically typed language, but it often infers types. By default, variables are immutable.
                </p>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-rust">
fn main() {
    // Immutable variable (default)
    let x = 5; // Type inferred as integer (i32 by default)
    println!("The value of x is: {}", x);

    // Mutable variable (using 'mut')
    let mut y = 10;
    println!("The value of y is: {}", y);
    y = 15; // This is allowed because y is mutable
    println!("The new value of y is: {}", y);

    // Explicit type annotation
    let z: f64 = 3.14; // f64 for double-precision float
    println!("The value of z is: {}", z);

    // Shadowing: create a new variable with the same name
    // and potentially a different type
    let spaces = "   ";
    println!("Spaces: '{}'", spaces);
    let spaces = spaces.len(); // Shadow `spaces` with its length (usize)
    println!("Number of spaces: {}", spaces);

    // Constants: declared with 'const' keyword, type must be annotated
    // Can only be set to a constant expression, not the result of a function call.
    const MAX_POINTS: u32 = 100_000;
    println!("Max points: {}", MAX_POINTS);
}
</code></pre>
                </div>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Common built-in data types:
                </p>
                <ul class="list-disc list-inside text-lg leading-relaxed text-gray-300 pl-6 space-y-2">
                    <li><strong class="text-blue-400">Integers:</strong> `i8, i16, i32, i64, i128` (signed), `u8, u16, u32, u64, u128` (unsigned). `isize`, `usize` (pointer size).</li>
                    <li><strong class="text-blue-400">Floating-Point Numbers:</strong> `f32`, `f64`.</li>
                    <li><strong class="text-blue-400">Booleans:</strong> `bool` (`true` or `false`).</li>
                    <li><strong class="text-blue-400">Characters:</strong> `char` (Unicode Scalar Value).</li>
                    <li><strong class="text-blue-400">Tuples:</strong> Fixed-size collections of different types.</li>
                    <li><strong class="text-blue-400">Arrays:</strong> Fixed-size collections of the same type.</li>
                </ul>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    1.4 Control Flow: Conditionals and Loops
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Rust's control flow is similar to other C-like languages but with some Rust-specific nuances.
                </p>
                <ul class="list-disc list-inside text-lg leading-relaxed text-gray-300 pl-6 space-y-3">
                    <li><strong class="text-blue-400">`if/else if/else` expressions:</strong> Note that `if` blocks are expressions and can return values.
                        <div class="code-block-container ml-4">
                            <button class="copy-button" onclick="copyCode(this)">
                                <i class="fas fa-copy"></i> Copy Code
                            </button>
<pre><code class="language-rust">
fn main() {
    let number = 7;

    if number < 5 {
        println!("condition was true");
    } else if number % 2 == 0 {
        println!("number is even");
    } else {
        println!("condition was false");
    }

    // Using if in a let statement (expression)
    let condition = true;
    let num_val = if condition { 5 } else { 6 }; // Both branches must return the same type
    println!("The value of num_val is: {}", num_val);
}
</code></pre>
                        </div>
                    </li>
                    <li><strong class="text-blue-400">Loops: `loop`, `while`, `for`</strong>
                        <div class="code-block-container ml-4">
                            <button class="copy-button" onclick="copyCode(this)">
                                <i class="fas fa-copy"></i> Copy Code
                            </button>
<pre><code class="language-rust">
fn main() {
    // infinite loop
    // loop {
    //     println!("again!");
    // }

    // loop with a return value
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2; // break returns a value
        }
    };
    println!("The result is {}", result); // Output: The result is 20

    // while loop
    let mut number = 3;
    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }
    println!("LIFTOFF!!!");

    // for loop with range
    for number in (1..4).rev() { // (start..end) is exclusive, .rev() reverses
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");

    // for loop iterating over a collection (safest way)
    let a = [10, 20, 30, 40, 50];
    for element in a.iter() {
        println!("The value is: {}", element);
    }
}
</code></pre>
                        </div>
                    </li>
                    <li><strong class="text-blue-400">`match` expression:</strong> Powerful pattern matching for control flow.
                        <div class="code-block-container ml-4">
                            <button class="copy-button" onclick="copyCode(this)">
                                <i class="fas fa-copy"></i> Copy Code
                            </button>
<pre><code class="language-rust">
fn main() {
    let coin = Coin::Quarter(UsState::Alabama);
    value_in_cents(coin);

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("{:?}", six); // Output: Some(6)
    println!("{:?}", none); // Output: None
}

#[derive(Debug)] // So we can inspect the state in a convenient way
enum UsState {
    Alabama,
    Alaska,
    // ... many more states
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // Coin can hold a UsState value
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin { // `match` must be exhaustive (cover all possibilities)
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => { // Destructure the value inside Quarter
            println!("Quarter from {:?}!", state);
            25
        },
    }
}

// Example with Option enum (used for representing optional values)
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None, // If x is None, return None
        Some(i) => Some(i + 1), // If x is Some(i), return Some(i+1)
    }
}
</code></pre>
                        </div>
                    </li>
                </ul>
            </section>

            <section class="mb-10">
                <h3 class="text-4xl font-bold text-teal-400 mb-6 border-b-2 border-teal-400 pb-2">
                    Part 2: Rust's Core Concepts - Ownership, Borrowing, Lifetimes
                </h3>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    These three concepts are what truly set Rust apart and enable its memory safety guarantees without a garbage collector. They are often the steepest part of the learning curve, but mastering them is key to writing effective Rust code.
                </p>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    2.1 Ownership
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Every value in Rust has a variable that's its <strong class="text-green-400">owner</strong>. There can only be one owner at a time. When the owner goes out of scope, the value will be dropped (memory is automatically deallocated). This compile-time check prevents "use-after-free" and "double-free" errors common in other languages.
                </p>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-rust">
fn main() {
    let s1 = String::from("hello"); // s1 owns "hello"
    println!("s1: {}", s1);

    let s2 = s1; // s1 is "moved" to s2. s1 is no longer valid.
                 // This prevents double-free errors.
    println!("s2: {}", s2);
    // println!("s1: {}", s1); // This would cause a compile-time error!

    // Data types that implement the Copy trait (like integers, booleans)
    // are copied, not moved.
    let x = 5;
    let y = x; // x is copied to y. Both are valid.
    println!("x: {}, y: {}", x, y);

    takes_ownership(s2); // s2's ownership moves to the function parameter
    // println!("s2 after function call: {}", s2); // Compile-time error!

    let s3 = String::from("world");
    let s4 = gives_ownership(s3); // s3's ownership moves to return value, then to s4
    println!("s4: {}", s4);
} // s4 and the String returned by takes_ownership goes out of scope and is dropped.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("Inside takes_ownership: {}", some_string);
} // Here, some_string goes out of scope and `drop` is called. Memory is freed.

fn gives_ownership(some_string: String) -> String { // some_string comes into scope
    println!("Inside gives_ownership: {}", some_string);
    some_string // some_string is returned and moves out to the calling function
}
</code></pre>
                </div>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    2.2 Borrowing
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    While ownership is powerful, it can be restrictive. You often need to access data without taking ownership. This is achieved through <strong class="text-green-400">borrowing</strong>, which allows you to create references to values without transferring ownership.
                </p>
                <ul class="list-disc list-inside text-lg leading-relaxed text-gray-300 pl-6 space-y-3">
                    <li><strong class="text-blue-400">Immutable references (`&T`):</strong> You can have multiple immutable references to a value simultaneously. They allow reading but not modifying the data.</li>
                    <li><strong class="text-blue-400">Mutable references (`&mut T`):</strong> You can have only one mutable reference to a value at a time. They allow both reading and modifying the data.
                        <p class="text-sm text-gray-400 mt-1">
                            This "one mutable XOR many immutable" rule at any given time is enforced by the <strong class="text-yellow-300">borrow checker</strong> at compile time, preventing data races and ensuring thread safety.
                        </p>
                    </li>
                </ul>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-rust">
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1); // Pass a reference (&s1)
    println!("The length of '{}' is {}.", s1, len); // s1 is still valid here

    let mut s2 = String::from("world");
    change(&mut s2); // Pass a mutable reference (&mut s2)
    println!("Changed string: {}", s2); // Output: Changed string: world, goodbye

    // This would cause a compile-time error:
    // let r1 = &mut s2;
    // let r2 = &mut s2; // Cannot have two mutable references at the same time
    // println!("{}, {}", r1, r2);

    // This would also cause a compile-time error:
    // let r1 = &s2;
    // let r2 = &s2;
    // let r3 = &mut s2; // Cannot have mutable and immutable references at the same time
    // println!("{}, {}, {}", r1, r2, r3);
}

fn calculate_length(s: &String) -> usize { // s is an immutable reference
    s.len()
} // Here, s goes out of scope. The value it refers to (s1 in main) is NOT dropped.

fn change(some_string: &mut String) { // some_string is a mutable reference
    some_string.push_str(", goodbye");
}
</code></pre>
                </div>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    2.3 Lifetimes
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    <strong class="text-green-400">Lifetimes</strong> are a Rust feature that ensures references are always valid. The Rust compiler uses lifetimes to determine how long references are valid. They are implicitly handled by the borrow checker for most common cases, but for more complex scenarios, especially when dealing with functions that return references or structs that hold references, you might need to annotate them explicitly.
                </p>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Lifetime annotations don't change how long a reference lives; they just describe the relationships between the lifetimes of multiple references, allowing the borrow checker to catch potential dangling references.
                </p>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-rust">
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result); // Output: The longest string is abcd

    let string4 = String::from("long string is long");
    {
        let string5 = String::from("xyz");
        let result = longest(string4.as_str(), string5.as_str());
        println!("The longest string is {}", result); // Output: The longest string is long string is long
    }
}

// 'a (read as "tick a") is a lifetime parameter.
// It tells the compiler that the returned reference will live as long as
// the shortest of the two input references.
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
</code></pre>
                    <p class="text-sm text-gray-400 mt-2">
                        Without the lifetime annotation `<'a>`, the compiler wouldn't know if the reference returned by `longest` would outlive the data it refers to. The annotation ensures that the returned reference is only valid as long as both `x` and `y` are valid.
                    </p>
                </div>
            </section>

            <section class="mb-10">
                <h3 class="text-4xl font-bold text-purple-400 mb-6 border-b-2 border-purple-400 pb-2">
                    Part 3: Data Structuring and Behavior - Structs, Enums, Traits
                </h3>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    3.1 Structs: Custom Data Types
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Like many other languages, Rust allows you to create custom data types to group related pieces of data. These are called <strong class="text-green-400">structs</strong> (short for "structures").
                </p>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-rust">
// Define a struct
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    // Create an instance of the struct
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    // Access fields
    println!("User 1's email: {}", user1.email);

    // Create a mutable instance and modify a field
    let mut user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotheruser"),
        active: false,
        sign_in_count: 5,
    };
    user2.active = true;
    println!("User 2's active status: {}", user2.active);

    // Function to create a new User instance
    let user3 = build_user(String::from("new@example.com"), String::from("newuser"));
    println!("User 3's username: {}", user3.username);

    // Using struct update syntax
    let user4 = User {
        email: String::from("email@example.com"),
        username: String::from("user_from_user2"),
        ..user2 // Take remaining fields from user2
    };
    println!("User 4's sign_in_count: {}", user4.sign_in_count);
}

fn build_user(email: String, username: String) -> User {
    User {
        email,      // Field init shorthand syntax
        username,   // If parameter name is same as field name
        active: true,
        sign_in_count: 1,
    }
}
</code></pre>
                </div>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    3.2 Enums: Enumerations
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    <strong class="text-green-400">Enums</strong> (enumerations) allow you to define a type by enumerating its possible variants. Each variant can optionally have data associated with it. This is incredibly powerful for representing distinct states or types of data.
                </p>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-rust">
#[derive(Debug)] // Allows printing with {:?}
enum IpAddrKind {
    V4,
    V6,
}

#[derive(Debug)]
struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32 }, // Anonymous struct
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message { // Enums can have methods using `impl`
    fn call(&self) {
        // method body would go here
        println!("Calling a message: {:?}", self);
    }
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    println!("IPv4: {:?}, IPv6: {:?}", four, six);

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };
    println!("Home IP: {:?}", home);

    let m1 = Message::Quit;
    let m2 = Message::Move { x: 10, y: 20 };
    let m3 = Message::Write(String::from("hello"));
    let m4 = Message::ChangeColor(0, 160, 255);

    m3.call(); // Output: Calling a message: Write("hello")

    // Using match with enums (as seen in Control Flow)
    let some_num = Some(5);
    match some_num {
        Some(value) => println!("Got a value: {}", value),
        None => println!("No value"),
    }
}
</code></pre>
                </div>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Rust's standard library uses enums extensively, notably `Option<T>` for nullable values and `Result<T, E>` for error handling.
                </p>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    3.3 Traits: Shared Behavior (Interfaces)
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    <strong class="text-green-400">Traits</strong> are Rust's way of defining shared behavior. They are similar to interfaces in other languages (like Java or Go). A trait defines a set of methods that a type must implement to satisfy that trait.
                </p>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-rust">
// Define a trait
pub trait Summary {
    fn summarize(&self) -> String; // Method signature
    
    // Default implementation (optional)
    fn summarize_author(&self) -> String {
        String::from("(Read more...)")
    }
}

// Define a struct
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

// Implement the Summary trait for NewsArticle
impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
    // We could override summarize_author here if needed
}

// Another struct
pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

// Implement the Summary trait for Tweet
impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
    // We can use the default summarize_author
}

// A function that accepts any type that implements the Summary trait
pub fn notify(item: &impl Summary) { // impl Trait syntax
    println!("Breaking news! {}", item.summarize());
}

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably already know, people"),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize()); // Output: 1 new tweet: horse_ebooks: of course, as you probably already know, people
    notify(&tweet); // Output: Breaking news! horse_ebooks: of course, as you probably already know, people

    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup!"),
        location: String::from("Pittsburgh, PA"),
        author: String::from("Iceburgh"),
        content: String::from("The Pittsburgh Penguins once again won the Stanley Cup."),
    };

    println!("New article: {}", article.summarize()); // Output: New article: Penguins win the Stanley Cup!, by Iceburgh (Pittsburgh, PA)
    notify(&article); // Output: Breaking news! Penguins win the Stanley Cup!, by Iceburgh (Pittsburgh, PA)
    println!("Author summary: {}", article.summarize_author()); // Using default implementation
}
</code></pre>
                </div>
                <p class="text-lg leading-relaxed text-gray-300 mt-4">
                    Traits are fundamental for writing generic and reusable code in Rust, allowing you to define behavior that can be shared across different types.
                </p>
            </section>

            <section class="mb-10">
                <h3 class="text-4xl font-bold text-teal-400 mb-6 border-b-2 border-teal-400 pb-2">
                    Part 4: Error Handling and The Rust Ecosystem
                </h3>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    4.1 Robust Error Handling: `panic!` vs. `Result<T, E>`
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Rust has two main categories for handling errors: recoverable and unrecoverable.
                </p>
                <ul class="list-disc list-inside text-lg leading-relaxed text-gray-300 pl-6 space-y-3">
                    <li><strong class="text-blue-400">`panic!` (Unrecoverable Errors):</strong> Used for unrecoverable errors where the program is in a bad state and cannot proceed. `panic!` will print an error message, unwind the stack, and exit. This is typically used for bugs in your code or situations that should never happen.
                        <div class="code-block-container ml-4">
                            <button class="copy-button" onclick="copyCode(this)">
                                <i class="fas fa-copy"></i> Copy Code
                            </button>
<pre><code class="language-rust">
fn main() {
    // This will cause a panic!
    // panic!("Crash and burn!");
    // let v = vec![1, 2, 3];
    // v[99]; // Accessing an out-of-bounds index will panic
}
</code></pre>
                        </div>
                    </li>
                    <li><strong class="text-blue-400">`Result<T, E>` (Recoverable Errors):</strong> For recoverable errors, Rust uses the `Result` enum, which has two variants:
                        <ul class="list-circle list-inside text-gray-400 pl-6 mt-2">
                            <li>`Ok(T)`: Indicates success and contains the successful value of type `T`.</li>
                            <li>`Err(E)`: Indicates failure and contains an error value of type `E`.</li>
                        </ul>
                        <p class="text-lg leading-relaxed text-gray-300 mt-2">
                            Functions that might fail return a `Result`. You then use `match` or helper methods like `unwrap()`, `expect()`, or the `?` operator to handle the outcome.
                        </p>
                        <div class="code-block-container ml-4">
                            <button class="copy-button" onclick="copyCode(this)">
                                <i class="fas fa-copy"></i> Copy Code
                            </button>
<pre><code class="language-rust">
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt"); // This might fail

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => panic!("Problem opening the file: {:?}", other_error),
        },
    };
    println!("File opened/created successfully: {:?}", f);

    // More concise error handling with .unwrap() (panics on Err)
    // let f_unwrap = File::open("another.txt").unwrap(); 
    // println!("File opened with unwrap: {:?}", f_unwrap);

    // More concise error handling with .expect() (panics with custom message on Err)
    // let f_expect = File::open("yetanother.txt").expect("Failed to open yetanother.txt");
    // println!("File opened with expect: {:?}", f_expect);

    // The '?' operator: propagates errors (used in functions that return Result)
    // Example:
    // fn read_username_from_file() -> Result<String, io::Error> {
    //     let mut f = File::open("username.txt")?; // If error, return it
    //     let mut s = String::new();
    //     f.read_to_string(&mut s)?; // If error, return it
    //     Ok(s)
    // }
}
</code></pre>
                        </div>
                    </li>
                </ul>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    4.2 Cargo: Rust's Build System and Package Manager
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    <strong class="text-green-400">Cargo</strong> is an indispensable tool for Rust development. It handles:
                </p>
                <ul class="list-disc list-inside text-lg leading-relaxed text-gray-300 pl-6 space-y-3">
                    <li><strong class="text-blue-400">Building your code:</strong> `cargo build`</li>
                    <li><strong class="text-blue-400">Running your code:</strong> `cargo run`</li>
                    <li><strong class="text-blue-400">Testing your code:</strong> `cargo test`</li>
                    <li><strong class="text-blue-400">Managing dependencies:</strong> Cargo uses `Cargo.toml` to declare dependencies on external libraries (called <strong class="text-yellow-300">crates</strong>).</li>
                    <li><strong class="text-blue-400">Publishing libraries:</strong> `cargo publish` to <a href="https://crates.io/" target="_blank" class="text-blue-400 hover:underline">crates.io</a>.</li>
                </ul>
                <p class="text-lg leading-relaxed text-gray-300">
                    The `Cargo.toml` file looks something like this:
                </p>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-toml">
[package]
name = "my_rust_project"
version = "0.1.0"
edition = "2021"

[dependencies]
# Example: Adding a dependency
rand = "0.8.5" # A popular crate for random number generation
</code></pre>
                </div>
                <p class="text-lg leading-relaxed text-gray-300">
                    Cargo fetches dependencies from <a href="https://crates.io/" target="_blank" class="text-blue-400 hover:underline">crates.io</a>, Rust's central package registry.
                </p>

                <h4 class="text-3xl font-semibold text-pink-400 mt-8 mb-4">
                    4.3 Concurrency in Rust
                </h4>
                <p class="text-lg leading-relaxed text-gray-300 mb-4">
                    Rust's ownership and borrowing rules extend to concurrency, allowing it to provide thread safety guarantees at compile time. This means you can write concurrent code without fear of data races.
                </p>
                <ul class="list-disc list-inside text-lg leading-relaxed text-gray-300 pl-6 space-y-3">
                    <li><strong class="text-blue-400">Threads:</strong> Rust's standard library provides `std::thread` for spawning new OS threads.</li>
                    <li><strong class="text-blue-400">Message Passing:</strong> Channels are used for safe communication between threads, similar to Go's channels. Rust's channels are implemented using `std::sync::mpsc` (Multiple Producer, Single Consumer).</li>
                    <li><strong class="text-blue-400">Shared State Concurrency:</strong> For sharing data between threads, Rust uses smart pointers like `Arc` (Atomic Reference Counted) for shared ownership and `Mutex` for mutual exclusion to ensure safe access.</li>
                </ul>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> Copy Code
                    </button>
<pre><code class="language-rust">
use std::thread;
use std::time::Duration;
use std::sync::mpsc; // Multiple Producer, Single Consumer

fn main() {
    let handle = thread::spawn(|| { // Spawn a new thread
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap(); // Wait for the spawned thread to finish

    // --- Channels example ---
    let (tx, rx) = mpsc::channel(); // Create a new channel

    thread::spawn(move || { // Move tx into the new thread
        let val = String::from("hi");
        tx.send(val).unwrap(); // Send value
        // println!("val is {}", val); // This would be a compile error because val was moved
    });

    let received = rx.recv().unwrap(); // Block and wait for value
    println!("Got: {}", received); // Output: Got: hi

    // Multiple producers, single consumer
    let (tx, rx) = mpsc::channel();
    let tx1 = mpsc::Sender::clone(&tx); // Clone sender for multiple producers

    thread::spawn(move || {
        tx1.send(String::from("from tx1")).unwrap();
    });

    thread::spawn(move || {
        tx.send(String::from("from tx2")).unwrap();
    });

    for received_msg in rx { // Iterate over received messages
        println!("Got: {}", received_msg);
    }
}
</code></pre>
                </div>
            </section>

            <section class="text-center pt-10">
                <h3 class="text-5xl font-extrabold text-white mb-6">
                    Conclusion: Embracing the Rust Way
                </h3>
                <p class="text-xl leading-relaxed text-gray-300 mb-6">
                    You've now embarked on a significant journey through Rust programming. You've gained an understanding of its foundational syntax, navigated the powerful yet challenging concepts of ownership, borrowing, and lifetimes, and explored how Rust structures data with structs and enums, and defines behavior with traits. You've also seen how Rust tackles error handling and leverages Cargo for project management and concurrency.
                </p>
                <p class="text-xl leading-relaxed text-gray-300 mb-6">
                    Rust's commitment to performance, memory safety, and concurrency without a garbage collector makes it an incredibly powerful and unique language. While its compile-time checks might seem strict at first, they ultimately lead to highly robust, efficient, and reliable software, making it an excellent choice for critical systems.
                </p>
                <p class="text-xl leading-relaxed text-gray-300">
                    We encourage you to continue honing your Rust skills by building projects, participating in the vibrant Rust community, and exploring its rich ecosystem of crates. The "Rust Way" of thinking will transform how you approach programming challenges. Happy and safe coding with Whizmath!
                </p>
            </section>
        </main>
    </div>

    <!-- Scroll to Top Button -->
    <button id="scrollToTopBtn" class="scroll-to-top-btn">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Three.js Animated Background
        let scene, camera, renderer, particles;
        const particleCount = 1500;
        const maxParticleSize = 0.5;

        function initThreeJS() {
            const canvas = document.getElementById('three-canvas');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Improve clarity on high-DPI screens
            camera.position.z = 5;

            // Create particles
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            const color1 = new THREE.Color(0xFF8C00); // Dark Orange (Rust's color)
            const color2 = new THREE.Color(0x8A2BE2); // BlueViolet (for contrast/tech feel)
            const color3 = new THREE.Color(0xCCCCCC); // Light Grey (for subtle sparkle)

            for (let i = 0; i < particleCount; i++) {
                // Position particles randomly in a cube
                positions[i * 3] = (Math.random() - 0.5) * 20; // x
                positions[i * 3 + 1] = (Math.random() - 0.5) * 20; // y
                positions[i * 3 + 2] = (Math.random() - 0.5) * 20; // z

                // Assign random color from a gradient
                const mixedColor = new THREE.Color();
                mixedColor.lerpColors(color1, color2, Math.random());
                mixedColor.lerp(color3, Math.random()); // Blend with third color

                colors[i * 3] = mixedColor.r;
                colors[i * 3 + 1] = mixedColor.g;
                colors[i * 3 + 2] = mixedColor.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: maxParticleSize,
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending, // For glowing effect
                sizeAttenuation: true // Particles closer to camera appear larger
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Add a simple light source for general ambiance
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);

            // Add a directional light for subtle highlights
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 1, 0); // From top
            scene.add(directionalLight);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            // Animate particles
            particles.rotation.x += 0.0005;
            particles.rotation.y += 0.0008;

            // Move particles slightly to create a floating effect
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3 + 1] += 0.001; // Move up slowly
                if (positions[i * 3 + 1] > 10) { // If particle goes too high, reset it to bottom
                    positions[i * 3 + 1] = -10;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true; // Tell Three.js to update the positions

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);
        window.onload = initThreeJS; // Initialize Three.js when the window loads

        // Scroll to Top Button functionality
        const scrollToTopBtn = document.getElementById("scrollToTopBtn");

        window.addEventListener("scroll", () => {
            if (window.pageYOffset > 300) { // Show button after scrolling 300px
                scrollToTopBtn.style.display = "flex";
            } else {
                scrollToTopBtn.style.display = "none";
            }
        });

        scrollToTopBtn.addEventListener("click", () => {
            window.scrollTo({
                top: 0,
                behavior: "smooth" // Smooth scroll
            });
        });

        // Copy Code Functionality
        function copyCode(buttonElement) {
            const codeBlock = buttonElement.nextElementSibling; // Get the <pre><code> element
            const textToCopy = codeBlock.innerText;

            // Use a temporary textarea to copy text (cross-browser compatible for iframes)
            const textArea = document.createElement("textarea");
            textArea.value = textToCopy;
            document.body.appendChild(textArea);
            textArea.select();

            try {
                const successful = document.execCommand('copy');
                const msg = successful ? 'Copied!' : 'Copy Failed!';
                
                // Provide visual feedback
                buttonElement.innerHTML = `<i class="fas fa-check"></i> ${msg}`;
                setTimeout(() => {
                    buttonElement.innerHTML = `<i class="fas fa-copy"></i> Copy Code`;
                }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
                buttonElement.innerHTML = `<i class="fas fa-times"></i> Error!`;
                setTimeout(() => {
                    buttonElement.innerHTML = `<i class="fas fa-copy"></i> Copy Code`;
                }, 2000);
            } finally {
                document.body.removeChild(textArea);
            }
        }
    </script>
</body>
</html>
